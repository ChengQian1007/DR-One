/*
 *      Centrale Intertielle
 * Wii Nunchuck + Wii Motion Plus
 *          Kalman
 *     sur Arduino Atmega168
 *
 * Florent Kermarrec @ FloConcept 2010
 *
 * Fichier      : CentraleInertielle
 * Description  :
 * Ce code interface une Arduino avec les capteurs
 * Wii Nunchuck et Wii Motion Plus
 * Un filtre de Kalman simplifiÌ© est mis en oeuvre
 * (Non mise Ì  jour des matrices de covariance de bruit)
 * Les angles sont ensuite retournÌ©s sur le lien sÌ©rie
 */

//-----------------------------
// Librairies
//-----------------------------
#include <math.h>
#include <Wire.h>
#include <Stdio.h>

//Definition structure Kalman Gyroscope
struct GyroKalman
{
	/* Matrice du Vecteur d'Ì©tat */
	double x_angle, x_bias;

	/* Matrice de covariance des erreurs */
	double P_00, P_01, P_10, P_11;

	/*
	 * Q est une matrice de covariance 2x2.
	 * Les bruits de mesure des Gyroscopes et AcceleromÌ¬tres sont
	 * supposÌ©s dÌ©couplÌ©s, la covariances de ces bruits est donc
	 * nulle et les termes non diagonaux de la matrice sont nuls
	 *
	 * Evolution de l'Ì©tat
	 *    x(k) = F.x(k-1) + B.u(k-1) + w
	 *  F : Evolution du systeme a partir de l'etat courant
	 *  B : Contribution de la commande Ì  l'Ì©volution du systÌ¬me.
	 *  w : bruit de process avec une distribution de covariance Q
	 *
	 *  Q est supposÌ©e linÌ©aire avec dt
	 */
	double Q_angle, Q_gyro;

	/*
	 * R est une matrice de covariance 1X1
	 * C'est la matrice de covariance du bruit d'observation (acceleromÌ¬tres)
	 * R est supposÌ©e linÌ©aire avec dt
	 */
	double R_angle;
};

//Definition structure RungeKutta
//Une integration Runge Kutta d'odre 4 est utilisÌ©e pour minimiser
//l'erreur d'intÌ©gration vitesse angulaire --> angle
struct RungeKutta
{
	double val_i_3;
	double val_i_2;
	double val_i_1;
	double previous;
};

//Constantes precalculÌ©es pour minimiser temps d'execution
static const double RadianToDegree = 57.2957795; // 180/PI
static const double DegreeToRadian = 0.0174532925; // PI/180


//2 Modes de fonctionnement pour les Gyros du Wii Motion Plus:
// Mode Slow : 2000 deg/s.
// Mode Fast :  500 deg/s.
//Le Kalman est rÌ©alisÌ© avec une sensibilitÌ© de 100 deg/s
static const int wmpSlowToDegreePerSec = 20;
static const int wmpFastToDegreePerSec = wmpSlowToDegreePerSec / 5;

//La fonction systÌ¬me millis() retourne une valeur en milliseconds, pour le calcul nous travaillons
//en secondes.
//Au lieu de diviser par 1000 nous multiplions par 0.001 pour minimiser le temps d'execution.
static const double SecondsPerMillis = 0.001;

//Configuration des matrices de covariances
// DegrÌ© de confiance Gyros/Accelerometres
// Dans un Kalman classique, ces valeurs sont rÌ©ajustÌ©es Ì  chaque itÌ©ration.
// et finissent par converger pour un systÌ¬me donnÌ©.
// Pour minimiser les calculs matriciels, ces valeurs sont ici fixÌ©es, un
// rÌ©glage proche de la valeur de convergence sera optimal.

// Matrice Q de covariance du bruit de process
// Wii Motion Plus
static const double Q_angle = 0.002; //(Kalman)
static const double Q_gyro = 0.1; //(Kalman)

// Matrice R de covariance du bruit d'observation
// Wii Nunchuck
static const float R_angle = .3; //.3 default

// Utilisation des structures de Kalman pour chaque axe de rotation
struct GyroKalman rollData;
struct GyroKalman pitchData;
struct GyroKalman yawData;

// Utilisation integration RungKutta sur le lacet
struct RungeKutta yawRK;

// Variable de lecture des Gyros
int readingsX;
int readingsY;
int readingsZ;

//Structure de donnÌ©es I2C Wii Motion Plus
byte data[6];

// Angle de rotation normalisÌ©s (å¡)
int yaw = 0;
int pitch = 0;
int roll = 0;

// Calibration du zero
int yaw0 = 0;
int pitch0 = 0;
int roll0 = 0;

//Variables Wii Motion Plus, si true, Mode slow
bool slowYaw;
bool slowPitch;
bool slowRoll;
bool debug = false;

//Variables Nunchuck
float accelAngleX = 0; //Angle X NunChuck
float accelAngleY = 0; //Angle Y NunChuck
float accelAngleZ = 0; //Angle Z NunChuck
float theta = 0; //Angle Theta Nunchuck

// Variables Programme
unsigned long lastread = 0; //derniere valeur de la date systÌ¬me

/*
 * Conversion des valeurs d'acceleration en radian.
 * On normalise les valeurs la norme de l'accÌ©lÌ©ration varie en fonction du temps.
 * La pluspart du temps lo vaut 0 et hi = 1023.
 */
float angleInRadians(int lo, int hi, int measured)
{
	float x = (hi - lo);
	return (float) (measured / x) * PI;
}

/*
 * Port Arduino de controle Wii Motion Plus / Wii Nunchuck sur I2C
 */
int WiiMotionPlusCtrl = 16;
int WiiNunchuckCtrl = 17;

/*
 * Switch du controle du Wii Motion Plus vers Wii Nunchuck sur I2C.
 *                    Adresse I2C identiques...
 */
void switchtonunchuck()
{
	digitalWrite(WiiMotionPlusCtrl, LOW);
	digitalWrite(WiiNunchuckCtrl, HIGH);
}

/*
 * Switch du controle du Wii Nunchuck vers Wii Motion Plus sur I2C.
 *                    Adresse I2C identiques...
 */
void switchtowmp()
{
	digitalWrite(WiiNunchuckCtrl, LOW);
	digitalWrite(WiiMotionPlusCtrl, HIGH);
}

/*
 * Initialisation du Wii Nunchuck
 */
void nunchuck_init()
{
	Wire.beginTransmission(0x52); // Device 0x52
	Wire.send(0xF0); // Adresse
	Wire.send(0x55); // Data
	Wire.endTransmission(); // Stop
	delay(100);
	Wire.beginTransmission(0x52); // Device 0x52
	Wire.send(0xFB); // Adresse
	Wire.send(0x00); // Data
	Wire.endTransmission(); // Stop
}

/*
 * Initialisation Arduino
 */
void setup()
{
	//Liaison sÌ©rie
	Serial.begin(115200);

	//Port Arduino de controle I2C
	pinMode(WiiMotionPlusCtrl, OUTPUT);
	pinMode(WiiNunchuckCtrl, OUTPUT);
	digitalWrite(WiiMotionPlusCtrl, LOW);
	digitalWrite(WiiNunchuckCtrl, LOW);

	//Initialisation I2C
	Wire.begin();

	//Initialisation Wii Motion Plus
	switchtowmp();
	wmpOn();
	calibrateZeroes();

	//Initialisation Wii Nunchuck
	switchtonunchuck();
	nunchuck_init();

	//Initialisation Kalmans
	initGyroKalman(&rollData, Q_angle, Q_gyro, R_angle);
	initGyroKalman(&pitchData, Q_angle, Q_gyro, R_angle);
	initGyroKalman(&yawData, Q_angle, Q_gyro, R_angle);

	//Initialisation RungeKutta Lacet
	yawRK.val_i_1 = 0;
	yawRK.val_i_2 = 0;
	yawRK.val_i_3 = 0;
	yawRK.previous = 0;

	//Sauvegarde temps systÌ¬me
	lastread = millis();
}

/*
 * Initialisation des structures de Kalman.
 *
 * kalman    Structure Kalman
 * Q_angle   Matrice covariance bruit d'Ì©volution des AcceleromÌ¬tres
 * Q_gyro    Matrice covariance bruit d'Ì©volution des Gyros
 * R_angle   Matrice covariance bruit ervation (jitter acceleromÌ¬tres)
 */
void initGyroKalman(struct GyroKalman *kalman, const float Q_angle, const float Q_gyro, const float R_angle)
{
	kalman->Q_angle = Q_angle;
	kalman->Q_gyro = Q_gyro;
	kalman->R_angle = R_angle;

	kalman->P_00 = 0;
	kalman->P_01 = 0;
	kalman->P_10 = 0;
	kalman->P_11 = 0;
}

/*
 * Activation Wii Motion Plus.
 */
void wmpOn()
{
	Wire.beginTransmission(0x53); //Device 0x53 (Wii Motion Plus demarre en 0x53)
	Wire.send(0xfe); //Adresse 0xFE
	Wire.send(0x04); //Data    0x04 --> Activation Wii Motion Plus
	Wire.endTransmission(); //STOP, Wii Motion Plus a l'adresse 0x52 maintenant
}
/*
 * Desactivation Wii Motion Plus.
 */
void wmpOff()
{
	Wire.beginTransmission(0x52); //Device 0x52
	Wire.send(0xf0); //Address
	Wire.send(0x55); //Data
	Wire.endTransmission(); //Stop
}
/*
 * Recuperation Infos Wii Motion Plus.
 */
void wmpSendZero()
{
	Wire.beginTransmission(0x52); //Device 0x52
	Wire.send(0x00); //Addres=0 --> on veut rÌ©cupÌ©rer les infos.
	Wire.endTransmission();
}

/*
 * Calibration du zero des Gyroscopes du Wii Motion Plus
 * Cette valeur est la valeur d'initialisation des filtres de Kalman
 * il est important que la centralle inertielle ne soit pas en mouvement
 * a l'initlisation.
 */
void calibrateZeroes()
{
	long y0 = 0;
	long p0 = 0;
	long r0 = 0;
	const int avg = 100;
	for (int i = 0; i < avg; i++)
	{
		wmpSendZero();
		Wire.requestFrom(0x52, 6);
		for (int t = 0; t < 6; t++)
		{
			data[t] = Wire.receive();
		}
		y0 += (((data[3] >> 2) << 8) + data[0]);
		r0 += (((data[4] >> 2) << 8) + data[1]);
		p0 += (((data[5] >> 2) << 8) + data[2]);
	}

	yaw0 = y0 / avg;
	roll0 = r0 / avg;
	pitch0 = p0 / avg;
}

/*
 * Recuperation des donnÌ©es Wii Motion Plus
 */
void receiveData()
{
	wmpSendZero(); //Initialisation
	Wire.requestFrom(0x52, 6); //Requete des 6 octets
	for (int i = 0; i < 6; i++)
	{
		data[i] = Wire.receive();
	}
	yaw = ((data[3] >> 2) << 8) + data[0];
	roll = ((data[4] >> 2) << 8) + data[1];
	pitch = ((data[5] >> 2) << 8) + data[2];

	slowPitch = data[3] & 1;
	slowYaw = data[3] & 2;
	slowRoll = data[4] & 2;

	yaw -= yaw0;
	roll -= roll0;
	pitch -= pitch0;
}

/*
 * Boucle principale
 */
void loop()
{
	//Determination temps systeme
	unsigned long now = millis();

	//Determiation du temps depuis derniÌ¬re itÌ©ration (en secondes)
	double dt = ((double) (now - lastread)) * SecondsPerMillis;

	//L'itÌ©ration de calcul n'est rÌ©alisÌ©e que si le temps dt est supÌ©rieur Ì  1/100 s
	if (dt >= 0.01)
	{

		//Sauvegarde du temps systÌ¬me
		lastread = now;

		//Recuperation data Wii Motion Plus
		switchtowmp();
		receiveData();

		//Recuperation data Wii Nunchuck
		switchtonunchuck();
		readNunchuck();

		//Selection des infos en fonction mode Slow ou Fast??
		const int rollScale = slowRoll ? wmpSlowToDegreePerSec : wmpFastToDegreePerSec;
		const int pitchScale = slowPitch ? wmpSlowToDegreePerSec : wmpFastToDegreePerSec;
		const int yawScale = slowYaw ? wmpSlowToDegreePerSec : wmpFastToDegreePerSec;

		//Affectations des donnÌ©es Gyroscope
		readingsX = -(roll / rollScale);
		readingsY = -(pitch / pitchScale);
		readingsZ = (yaw / yawScale);

		//PrÌ©diction Kalman  (Roulis,Tangage)
		predict(&rollData, readingsX * DegreeToRadian, dt);
		predict(&pitchData, readingsY * DegreeToRadian, dt);

		//Mise Ì  jour Kalman (Roulis,Tangage)
		double rollAngle = update(&rollData, accelAngleX);
		double pitchAngle = update(&pitchData, accelAngleY);

		//Integration RungeKutta Lacet
		double yawAngle = computeRK4(&yawRK, readingsZ * DegreeToRadian * dt);

		//Serial.print("GyroX: ");
		//Serial.print(readingsX);
		//Serial.print(" ");

		//Serial.print("GyroY: ");
		//Serial.print(readingsY);
		//Serial.print(" ");

		//Serial.print("GyroZ: ");
		//Serial.print(readingsZ);
		//Serial.println();

		//Serial.print("AngleX: ");
		//Serial.print(accelAngleX);
		//Serial.print(accelAngleX*RadianToDegree);
		//Serial.print("AngleY: ");
		//Serial.print(accelAngleY);
		//Serial.print(accelAngleY*RadianToDegree);
		//Serial.println();/

		Serial.print(rollAngle * RadianToDegree, 3);
		Serial.print(" ");
		Serial.print(pitchAngle * RadianToDegree, 3);
		Serial.print(" ");
		Serial.print(yawAngle * RadianToDegree, 3);
		Serial.println();
	}
}

/*
 * Etape de prÌ©diction du Kalman
 *
 * kalman    Structude de Kalman
 * dotAngle  Vitesse angulaire du Gyro, c'est directement la valeur normalisÌ©e renvoyÌ©e par le Gyro Wii Motion Plus.
 * dt        Temps passÌ© depuis la derniÌ¬re itÌ©ration
 *
 */
void predict(struct GyroKalman *kalman, double dotAngle, double dt)
{

	kalman->x_angle += dt * (dotAngle - kalman->x_bias);
	kalman->P_00 += -1 * dt * (kalman->P_10 + kalman->P_01) + dt * dt * kalman->P_11 + kalman->Q_angle;
	kalman->P_01 += -1 * dt * kalman->P_11;
	kalman->P_10 += -1 * dt * kalman->P_11;
	kalman->P_11 += kalman->Q_gyro;
}

/*
 * Etape de mise Ì  jour du Kalman
 *
 * kalman    Structure de Kalman
 * angle_m   Angle observÌ© Ì  partir de l'accÌ©leromÌ¬tre du Wii NunChuck
 */
double update(struct GyroKalman *kalman, double angle_m)
{
	const double y = angle_m - kalman->x_angle;
	const double S = kalman->P_00 + kalman->R_angle;
	const double K_0 = kalman->P_00 / S;
	const double K_1 = kalman->P_10 / S;

	kalman->x_angle += K_0 * y;
	kalman->x_bias += K_1 * y;

	kalman->P_00 -= K_0 * kalman->P_00;
	kalman->P_01 -= K_0 * kalman->P_01;
	kalman->P_10 -= K_1 * kalman->P_00;
	kalman->P_11 -= K_1 * kalman->P_01;

	return kalman->x_angle;
}

/*
 * IntÌ©gration Runge Kutta d'ordre 4 sur l'angle de Lacet
 * Il n'est pas possible de rÌ©aliser un Kalman sur l'angle de lacet, car il n'existe pas de mesure d'observation.
 * ( Il n'est pas possible de mesurer le lacet Ì  partir de l'acceleromÌ¬tre).
 * L'intÌ©gration Runge Kutta lisse les valeurs, mais le biais est toujours prÌ©sent.
 */
double computeRK4(struct RungeKutta *rk, double val_i_0)
{
	rk->previous += 0.16667 * (rk->val_i_3 + 2 * rk->val_i_2 + 2 * rk->val_i_1 + val_i_0);
	rk->val_i_3 = rk->val_i_2;
	rk->val_i_2 = rk->val_i_1;
	rk->val_i_1 = val_i_0;
	return rk->previous;
}

/*
 * Ecriture d'un zero vers le Nunchuck.
 */
void send_zero()
{
	Wire.beginTransmission(0x52); // transmit to device 0x52 (nunchuck)
	Wire.send(0x00); // sends one byte (nunchuck)
	Wire.endTransmission(); // stop transmitting (nunchuck)
}

/*
 * Lecture des donnees du Wii Nunchuck.
 */
void readNunchuck()
{
	int cnt = 0;
	byte outbuf[6];

	//RequÌ¬te de lecture
	Wire.requestFrom(0x52, 6);

	//Reception des donnÌ©es
	while (Wire.available())
	{
		outbuf[cnt] = Wire.receive();
		cnt++;
	}

	send_zero();

	//Si les donnÌ©es sont rÌ©cupÌ©rÌ©es, le calcul est effectuÌ©
	if (cnt >= 5) //(NunChuck)
	{
		processAccelerometers(outbuf); //(NunChuck)
	}
}

/*
 * Observation des angles Ì  partir des accÌ©lÌ©romÌ¬tres du Wii Nunchuck
 *
 * The execution of this function results in the updating of 3 globals, accelAngleX, accelAngleY, and accelAngleZ with the angle in radians.
 * If the Wii Motion Plus and the Nunchuck are oriented together in the way this code assumes then:
 *    Nunchuck X maps to Wii Motion Plus Roll
 *    Nunchuck Y maps to Wii Motion Plus Pitch
 *    Nunchuck Z maps to Wii Motion Plus Yaw
 *
 */
void processAccelerometers(byte outbuf[])
{
	//Pull the bits out of the array for each axis.  Other implementations floating around are incorrect with the way
	//they operate on the lower 2 bits.  Thanks to evilBunny for this code.
	int ax_m = (outbuf[2] << 2) + ((outbuf[5] >> 2) & 0x03);
	int ay_m = (outbuf[3] << 2) + ((outbuf[5] >> 4) & 0x03);
	int az_m = (outbuf[4] << 2) + ((outbuf[5] >> 6) & 0x03);

	//The nunchuk accelerometers read ~511 steady state.  Remove that to zero the values.
	ax_m -= 511;
	ay_m -= 511;
	az_m -= 511;

	if (debug)
	{
		Serial.print("ax: ");
		Serial.print(ax_m);
		Serial.print("ay: ");
		Serial.print(ay_m);
		Serial.print("az: ");
		Serial.println(az_m);
	}

	//The real purpose of this method is to convert the accelometer values into usable angle values.
	//Knuckles904 pointed me to this app note: http://www.freescale.com/files/sensors/doc/app_note/AN3461.pdf
	//That paper gives the math for implementing a tilt sensor using 3-axis accelerometers.  Roll(X) and pitch(Y) are directly
	//applicable.  Yaw(Z) is not since there is no 'tilt' with respect to the earth.

	//Once the accelerometer values have been biased to zero (by subtracting 511 above), then they should fall in a range from
	//-512 to +511.
	double x = angleInRadians(-512, 511, ax_m);
	double y = angleInRadians(-512, 511, ay_m);
	double z = angleInRadians(-512, 511, az_m);

	//compute values that are used in multiple places
	double xSquared = x * x;
	double ySquared = y * y;
	double zSquared = z * z;

	accelAngleX = atan2(x, sqrt(ySquared + zSquared));
	accelAngleY = atan2(y, sqrt(xSquared + zSquared));

}
